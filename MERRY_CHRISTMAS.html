<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ğŸ„ğŸ„å°æºªç²¥ç²¥ğŸ„ğŸ„</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: radial-gradient(1200px 800px at 50% 35%, rgba(255, 120, 180, 0.08), rgba(10, 0, 18, 0.9) 60%, #05000a 100%);
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC",
          "Microsoft YaHei", sans-serif;
      }

      #canvas {
        position: fixed;
        inset: 0;
      }

      .ui {
        position: fixed;
        top: 18px;
        left: 18px;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
        z-index: 20;
      }

      .title {
        font-size: clamp(28px, 4vw, 62px);
        letter-spacing: 10px;
        font-weight: 650;
        opacity: 0.95;
        text-transform: uppercase;
        background: linear-gradient(180deg, #ffe6f1 0%, #ff93c9 40%, #ffd27a 100%);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        text-shadow: 0 0 30px rgba(255, 160, 220, 0.22), 0 0 90px rgba(255, 210, 122, 0.12);
        margin-bottom: 8px;
      }

      .hint {
        position: fixed;
        left: 18px;
        bottom: 16px;
        pointer-events: none;
        color: rgba(255, 255, 255, 0.55);
        font-size: 12px;
        letter-spacing: 0.5px;
        line-height: 1.6;
      }

      .hint kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 11px;
        padding: 1px 6px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(255, 255, 255, 0.7);
      }

      /* When hidden class is applied to specific elements */
      .ui-hidden {
        opacity: 0;
        pointer-events: none !important;
      }

      /* Loading */
      #loader {
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.8s ease-out;
      }

      .loader-text {
        color: rgba(255, 210, 122, 0.85);
        font-size: 12px;
        letter-spacing: 4px;
        margin-top: 18px;
        text-transform: uppercase;
        font-weight: 300;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 1px solid rgba(255, 210, 122, 0.18);
        border-top: 1px solid rgba(255, 210, 122, 0.9);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Upload Button */
      .upload-wrapper {
        margin-top: 18px;
        pointer-events: auto;
        text-align: center;
        transition: opacity 0.5s ease;
      }

      .upload-btn {
        background: rgba(20, 20, 20, 0.55);
        border: 1px solid rgba(255, 210, 122, 0.35);
        color: rgba(255, 210, 122, 0.9);
        padding: 10px 22px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 3px;
        font-size: 10px;
        transition: all 0.35s;
        display: inline-block;
        border-radius: 12px;
        backdrop-filter: blur(6px);
      }

      .upload-btn:hover {
        background: rgba(255, 210, 122, 0.92);
        color: #120016;
        box-shadow: 0 0 22px rgba(255, 160, 220, 0.18), 0 0 18px rgba(255, 210, 122, 0.25);
      }

      .hint-text {
        color: rgba(255, 210, 122, 0.5);
        font-size: 9px;
        margin-top: 8px;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      #file-input {
        display: none;
      }

      /* Camera buttons */
      .cam-btn {
        position: relative;
        width: 40px;
        height: 40px;
        border-radius: 999px;
        background: rgba(20, 20, 20, 0.55);
        border: 1px solid rgba(255, 210, 122, 0.35);
        color: rgba(255, 210, 122, 0.9);
        backdrop-filter: blur(6px);
        cursor: pointer;
        pointer-events: auto;
        transition: all 0.25s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
      }

      .cam-btn:hover {
        background: rgba(255, 210, 122, 0.14);
        color: #fff;
        transform: scale(1.05);
      }

      .cam-buttons-group {
        display: flex;
        gap: 8px;
        pointer-events: auto;
      }

      /* Webcam preview */
      #webcam-wrapper {
        position: fixed;
        bottom: 18px;
        left: 18px;
        width: 160px;
        height: 120px;
        border: 1px solid rgba(255, 210, 122, 0.28);
        overflow: hidden;
        opacity: 0.95;
        pointer-events: none;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
      }

      /* Action panel */
      .action-panel {
        position: fixed;
        top: 50%;
        right: 18px;
        transform: translateY(-50%);
        z-index: 30;
        width: 168px;
        padding: 12px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 210, 122, 0.28);
        backdrop-filter: blur(10px);
        pointer-events: auto;
      }

      .action-title {
        color: rgba(255, 230, 241, 0.95);
        font-size: 12px;
        letter-spacing: 2px;
        text-transform: uppercase;
        margin-bottom: 10px;
        text-align: center;
      }

      .action-btn {
        width: 100%;
        display: block;
        padding: 10px 10px;
        margin: 8px 0;
        border-radius: 12px;
        background: rgba(20, 20, 20, 0.55);
        border: 1px solid rgba(255, 210, 122, 0.28);
        color: rgba(255, 230, 241, 0.9);
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }

      .action-btn:hover {
        background: rgba(255, 210, 122, 0.14);
        border-color: rgba(255, 210, 122, 0.45);
        transform: translateY(-1px);
      }

      /* æ»‘åŠ¨æ¡æ ·å¼ */
      .slider-container {
        width: 100%;
        margin: 12px 0;
        padding: 0 4px;
      }

      .slider-label {
        color: rgba(255, 230, 241, 0.85);
        font-size: 10px;
        letter-spacing: 1px;
        margin-bottom: 6px;
        text-align: center;
      }

      .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: rgba(255, 210, 122, 0.2);
        outline: none;
        -webkit-appearance: none;
        appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 210, 122, 0.9);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .slider::-webkit-slider-thumb:hover {
        background: rgba(255, 230, 241, 0.95);
        transform: scale(1.2);
      }

      .slider::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 210, 122, 0.9);
        cursor: pointer;
        border: none;
        transition: all 0.2s ease;
      }

      .slider::-moz-range-thumb:hover {
        background: rgba(255, 230, 241, 0.95);
        transform: scale(1.2);
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
      }
    </script>
  </head>

  <body>
    <div id="loader">
      <div class="spinner"></div>
      <div class="loader-text">Loading Holiday Magic</div>
    </div>

    <div id="canvas"></div>

    <div class="ui">
      <div class="title">MERRY&nbsp;CHRISTMAS</div>

      <div class="upload-wrapper">
        <label class="upload-btn">
            ğŸ“·æŒ‚æ›´å¤šç…§ç‰‡åˆ°æ ‘ä¸ŠğŸ„
          <input type="file" id="file-input" multiple accept="image/png,image/jpeg,image/jpg" />
        </label>
        <div class="hint-text">Press 'H' to Hide Controls</div>
      </div>

      <!-- æ‘„åƒå¤´æŒ‰é’®ç»„ -->
      <div class="cam-buttons-group">
        <!-- æ‘„åƒå¤´å¼€å…³ï¼šé»˜è®¤å…³é—­ï¼ˆä¸å¼¹æƒé™ï¼‰ -->
        <button id="toggle-webcam-btn" class="cam-btn" title="æ‘„åƒå¤´å¼€å…³ï¼ˆå¼€å¯åæ‰‹åŠ¿æ§åˆ¶ï¼‰">ğŸ¥</button>
        <!-- åˆ‡æ¢å‰/åæ‘„åƒå¤´ï¼šä»…åœ¨æ‘„åƒå¤´å¼€å¯æ—¶å¯ç”¨ -->
        <button id="switch-camera-btn" class="cam-btn" title="åˆ‡æ¢å‰/åæ‘„åƒå¤´" style="display:none;">ğŸ”„</button>
      </div>
    </div>

    <!-- å³ä¾§åŠ¨ä½œé¢æ¿ï¼šæ— æ‘„åƒå¤´ä¹Ÿå¯æ“ä½œï¼ˆå¯¹é½ åœ£è¯æ ‘.htmlï¼‰ -->
    <div id="action-panel" class="action-panel">
      <div class="action-title">åŠ¨ä½œ</div>
      <button id="btn-collapse" class="action-btn">æ”¶å›åœ£è¯æ ‘</button>
      <button id="btn-explode" class="action-btn">çˆ†å¼€åœ£è¯æ ‘</button>
      <button id="btn-autorotate" class="action-btn">è‡ªåŠ¨æ—‹è½¬ï¼šå¼€</button>
      <div class="slider-container">
        <div class="slider-label">æ—‹è½¬é€Ÿåº¦</div>
        <input type="range" min="0" max="100" value="35" class="slider" id="rotation-speed-slider">
      </div>
    </div>

    <!-- Webcam hidden structure -->
    <div id="webcam-wrapper">
      <video id="webcam" autoplay playsinline style="display:none;"></video>
      <canvas id="webcam-preview"></canvas>
    </div>

    <div class="hint">
      æ‹–åŠ¨ï¼šæ—‹è½¬è§†è§’ Â· æ»šè½®ï¼šç¼©æ”¾ Â· å³é”®ï¼šå¹³ç§»<br />
      <kbd>Space</kbd> æš‚åœ/ç»§ç»­åŠ¨ç”» Â· <kbd>R</kbd> è§†è§’å¤ä½ Â· <kbd>M</kbd> éŸ³ä¹å¼€å…³ Â· <kbd>H</kbd> éšè—/æ˜¾ç¤ºæ§ä»¶
    </div>

    <script type="module">
      // @ts-check
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

      // ============================================================
      // é…ç½®å¸¸é‡ï¼ˆé›†ä¸­åœ¨é¡¶éƒ¨ï¼Œä¾¿äºä½ å¿«é€Ÿè°ƒé£æ ¼/æ€§èƒ½ï¼‰
      // ============================================================
      const CONFIG = {
        tree: {
          particleCount: 52000,
          height: 3.9,
          radius: 1.85,
          pointSize: 18.0,
          breatheAmp: 0.07,
          breatheSpeed: 0.85,
          driftAmp: 0.035
        },
        snow: {
          count: 5200,
          area: { x: 12, y: 7.5, z: 12 },
          yTop: 5.8,
          yBottom: -1.4,
          speedMin: 0.18,
          speedMax: 0.85,
          sizeMin: 5.0,
          sizeMax: 12.0,
          opacity: 0.55
        },
        rings: {
          ringCount: 3,
          y: -0.05,
          radii: [2.55, 2.85, 3.15],
          particlesPerRing: 1600,
          pointSize: 18.0,
          rotateSpeed: [0.12, -0.09, 0.07]
        },
        heart: {
          y: 4.32,
          scale: 0.72,
          rotateSpeed: 0.55,
          emissiveIntensity: 1.65
        },
        camera: {
          fov: 45,
          position: { x: 3.35, y: 2.25, z: 5.25 },
          target: { x: 0, y: 1.65, z: 0 },
          minDistance: 3.4,
          maxDistance: 9.5
        },
        post: {
          bloomStrength: 0.85,
          bloomRadius: 0.20,
          bloomThreshold: 0.75
        },
        renderer: {
          pixelRatioMax: 2,
          exposure: 0.82
        },
        colors: {
          bg: 0x05000a,
          fog: 0x120016,
          energyCenter: new THREE.Color("#ff7bc8"),
          energyMid: new THREE.Color("#ffb2c9"),
          energyEdge: new THREE.Color("#ffd27a"),
          snowA: new THREE.Color("#ffffff"),
          snowB: new THREE.Color("#ffe3f2"),
          gold: new THREE.Color("#ffd27a")
        }
      };

      const STATE = {
        paused: false,
        autoRotate: true,
        webcamEnabled: false,
        mode: "TREE", // TREE | SCATTER | FOCUS
        focusTarget: null,
        explode: 0, // 0..1ï¼Œé©±åŠ¨æ ‘ä½“ç²’å­çˆ†å¼€
        hand: { detected: false, x: 0, y: 0 },
        gesture: { last: "NONE", stable: "NONE", sameCount: 0 }
      };

      // ============================================================
      // åœºæ™¯åˆå§‹åŒ–
      // ============================================================
      const mount = /** @type {HTMLElement} */ (document.getElementById("canvas"));
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.14);

      const camera = new THREE.PerspectiveCamera(CONFIG.camera.fov, window.innerWidth / window.innerHeight, 0.1, 60);
      camera.position.set(CONFIG.camera.position.x, CONFIG.camera.position.y, CONFIG.camera.position.z);
      camera.lookAt(CONFIG.camera.target.x, CONFIG.camera.target.y, CONFIG.camera.target.z);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, CONFIG.renderer.pixelRatioMax));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = CONFIG.renderer.exposure;
      mount.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.enablePan = true;
      controls.minDistance = CONFIG.camera.minDistance;
      controls.maxDistance = CONFIG.camera.maxDistance;
      controls.target.set(CONFIG.camera.target.x, CONFIG.camera.target.y, CONFIG.camera.target.z);
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.35;
      
      // åŒæ­¥åˆå§‹æ—‹è½¬é€Ÿåº¦åˆ°æ»‘åŠ¨æ¡
      setTimeout(() => {
        const slider = /** @type {HTMLInputElement | null} */ (document.getElementById("rotation-speed-slider"));
        if (slider) slider.value = (controls.autoRotateSpeed * 100).toString();
      }, 100);

      // è½»å¾®ç¯å…‰ï¼Œä¸»è¦ç”¨äºé¡¶éƒ¨çˆ±å¿ƒâ€œå®ä½“æ„Ÿâ€
      scene.add(new THREE.AmbientLight(0xffffff, 0.2));
      const key = new THREE.DirectionalLight(0xffe1f0, 0.55);
      key.position.set(3, 6, 4);
      scene.add(key);

      // ============================================================
      // Shaderï¼ˆç²’å­ï¼šæŸ”å’Œåœ†å½¢è¡°å‡ + åŠ æ³•æ··åˆå‘å…‰ï¼‰
      // ============================================================
      const PARTICLE_VERTEX = /* glsl */ `
        uniform float uTime;
        uniform float uPointSize;
        uniform float uBreatheAmp;
        uniform float uBreatheSpeed;
        uniform float uDriftAmp;
        uniform float uExplode;
        attribute float aSeed;
        attribute float aIntensity;
        attribute vec3 aDir;
        attribute float aExplode;
        varying float vIntensity;
        varying float vSeed;

        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
          vIntensity = aIntensity;
          vSeed = aSeed;

          vec3 p = position;
          float t = uTime;

          // å‘¼å¸/é—ªçƒï¼ˆéšç²’å­ seed åˆ†æ•£ç›¸ä½ï¼‰
          float breathe = 1.0 + uBreatheAmp * sin(t * uBreatheSpeed + aSeed * 6.28318);

          // è½»å¾®æ¼‚æµ®/æŠ–åŠ¨ï¼ˆé¿å…å®Œå…¨é™æ­¢ï¼‰
          float n1 = sin(t * 0.9 + aSeed * 12.3);
          float n2 = cos(t * 0.8 + aSeed * 7.7);
          p.y += (n1 * 0.06 + n2 * 0.04) * uDriftAmp;
          p.x += (n2 * 0.05) * uDriftAmp;
          p.z += (n1 * 0.05) * uDriftAmp;

          // çˆ†å¼€ï¼šæ²¿â€œä»æ ‘å¿ƒå‘å¤–â€çš„æ–¹å‘æ‰©æ•£ï¼Œå¸¦ä¸€ç‚¹æ—‹æ¶¡/æ¼‚ç§»æ›´è‡ªç„¶
          float e = clamp(uExplode, 0.0, 1.0);
          float ee = e * e;
          float swirl = ee * (0.45 + 0.35 * sin(t * 0.35 + aSeed));
          float ang = swirl * (1.2 + 0.8 * sin(aSeed * 3.1));
          vec3 dir = normalize(aDir + vec3(0.0, 0.15, 0.0));
          vec3 off = dir * (aExplode * ee);
          float cs = cos(ang);
          float sn = sin(ang);
          off.xz = mat2(cs, -sn, sn, cs) * off.xz;
          p += off;

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float dist = max(0.001, -mv.z);
          float size = uPointSize * (1.0 / dist);
          size *= mix(0.85, 1.35, aIntensity) * breathe;
          gl_PointSize = size;
        }
      `;

      const PARTICLE_FRAGMENT = /* glsl */ `
        precision highp float;
        uniform vec3 uColorCenter;
        uniform vec3 uColorMid;
        uniform vec3 uColorEdge;
        varying float vIntensity;
        varying float vSeed;

        void main() {
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          // æŸ”å’Œåœ†ç‚¹ï¼ˆå¤–åœˆè¡°å‡æ›´æŸ”ï¼‰
          float core = smoothstep(0.5, 0.02, d);
          float halo = smoothstep(0.5, 0.18, d);

          // è‰²å½©ï¼šä¸­å¿ƒæš–ç²‰ -> çŠç‘šç²‰é«˜å…‰ -> é‡‘è‰²è¾¹ç¼˜
          float edgeMask = smoothstep(0.24, 0.5, d);
          vec3 col = mix(uColorCenter, uColorMid, clamp(1.0 - vIntensity, 0.0, 1.0));
          col = mix(col, uColorEdge, edgeMask * 0.85);

          // è½»å¾®â€œèƒ½é‡é—ªçƒâ€ï¼ˆå¼ºåº¦ç»´åº¦ï¼Œé¿å…åˆºçœ¼ï¼‰
          float sparkle = 0.93 + 0.10 * sin(vSeed * 18.0);
          col *= sparkle;

          // é™ä½æ•´ä½“èƒ½é‡å¯†åº¦ï¼Œé¿å… Bloom è¿‡æ›ç‚¸ç™½
          float alpha = core * 0.70 + halo * 0.22;
          alpha *= mix(0.30, 0.78, vIntensity);
          col *= 0.82;

          if (alpha < 0.02) discard;
          gl_FragColor = vec4(col, alpha);
        }
      `;

      /**
       * @param {{
       *  pointSize: number,
       *  breatheAmp: number,
       *  breatheSpeed: number,
       *  driftAmp: number,
       *  colorCenter: THREE.Color,
       *  colorMid: THREE.Color,
       *  colorEdge: THREE.Color,
       *  blending: THREE.Blending,
       *  opacity?: number
       * }} opts
       */
      function makeParticleMaterial(opts) {
        const uniforms = {
          uTime: { value: 0 },
          uPointSize: { value: opts.pointSize },
          uBreatheAmp: { value: opts.breatheAmp },
          uBreatheSpeed: { value: opts.breatheSpeed },
          uDriftAmp: { value: opts.driftAmp },
          uExplode: { value: 0 },
          uColorCenter: { value: opts.colorCenter.clone() },
          uColorMid: { value: opts.colorMid.clone() },
          uColorEdge: { value: opts.colorEdge.clone() }
        };

        const mat = new THREE.ShaderMaterial({
          uniforms,
          vertexShader: PARTICLE_VERTEX,
          fragmentShader: PARTICLE_FRAGMENT,
          transparent: true,
          depthWrite: false,
          depthTest: true,
          blending: opts.blending
        });

        // è®©é›ªèŠ±æ›´â€œé›¾åŒ–â€ä¸€ç‚¹
        if (typeof opts.opacity === "number") mat.opacity = opts.opacity;

        return { mat, uniforms };
      }

      // ============================================================
      // PinkTreeParticlesï¼šæ ‘ä½“ç²’å­ï¼ˆåœ†é”¥ä½“ç§¯äº‘ï¼‰
      // ============================================================
      function createTreeParticles() {
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.tree.particleCount * 3);
        const seeds = new Float32Array(CONFIG.tree.particleCount);
        const intensities = new Float32Array(CONFIG.tree.particleCount);
        const dirs = new Float32Array(CONFIG.tree.particleCount * 3);
        const explodeDist = new Float32Array(CONFIG.tree.particleCount);

        for (let i = 0; i < CONFIG.tree.particleCount; i++) {
          // yï¼šåå‘ä¸­ä¸‹éƒ¨æ›´å¯†ä¸€äº›
          const t = Math.pow(Math.random(), 0.62);
          const y = t * CONFIG.tree.height;

          // åœ†é”¥åŠå¾„éšé«˜åº¦çº¿æ€§æ”¶æ•›
          const coneR = (1 - y / CONFIG.tree.height) * CONFIG.tree.radius;

          // ä½“ç§¯é‡‡æ ·ï¼šè¶Šé ä¸­å¿ƒè¶Šå¯†
          const rr = coneR * Math.pow(Math.random(), 0.55);
          const a = Math.random() * Math.PI * 2;
          const x = Math.cos(a) * rr;
          const z = Math.sin(a) * rr;

          // å°å¹…éšæœºæ‰°åŠ¨ï¼Œåˆ¶é€ â€œä½“ç§¯äº‘â€æ„Ÿ
          const j = (Math.random() - 0.5) * 0.08;
          positions[i * 3 + 0] = x + j;
          positions[i * 3 + 1] = y + (Math.random() - 0.5) * 0.06;
          positions[i * 3 + 2] = z + j;

          seeds[i] = Math.random() * 1000;

          // intensityï¼šä¸­å¿ƒæ›´äº®ï¼Œå¤–ç¼˜æ›´æ·¡
          const normR = coneR <= 0.0001 ? 0 : rr / coneR;
          intensities[i] = THREE.MathUtils.clamp(1.0 - normR * 0.85, 0, 1);

          // çˆ†å¼€æ–¹å‘ï¼šä»¥ (x,z) å¾„å‘ä¸ºä¸» + å°‘é‡å™ªå£°
          const dx = x + (Math.random() - 0.5) * 0.6;
          const dy = (Math.random() - 0.5) * 0.2;
          const dz = z + (Math.random() - 0.5) * 0.6;
          const len = Math.hypot(dx, dy, dz) || 1;
          dirs[i * 3 + 0] = dx / len;
          dirs[i * 3 + 1] = dy / len;
          dirs[i * 3 + 2] = dz / len;

          // çˆ†å¼€è·ç¦»ï¼šåº•éƒ¨æ›´æ‰©æ•£ã€é¡¶éƒ¨ç•¥æ”¶æ•›ï¼Œæ•´ä½“åƒèƒ½é‡äº‘è†¨èƒ€
          const height01 = y / CONFIG.tree.height;
          explodeDist[i] = 2.2 + (1 - height01) * 2.6 + Math.random() * 1.4;
        }

        geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geo.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
        geo.setAttribute("aIntensity", new THREE.BufferAttribute(intensities, 1));
        geo.setAttribute("aDir", new THREE.BufferAttribute(dirs, 3));
        geo.setAttribute("aExplode", new THREE.BufferAttribute(explodeDist, 1));

        const { mat, uniforms } = makeParticleMaterial({
          pointSize: CONFIG.tree.pointSize,
          breatheAmp: CONFIG.tree.breatheAmp,
          breatheSpeed: CONFIG.tree.breatheSpeed,
          driftAmp: CONFIG.tree.driftAmp,
          colorCenter: CONFIG.colors.energyCenter,
          colorMid: CONFIG.colors.energyMid,
          colorEdge: CONFIG.colors.energyEdge,
          blending: THREE.AdditiveBlending
        });

        const points = new THREE.Points(geo, mat);
        points.position.y = -0.2;
        return { points, uniforms };
      }

      // ============================================================
      // SnowParticlesï¼šèƒŒæ™¯é›ªèŠ±ï¼ˆå¤šæ·±åº¦/å¤šé€Ÿåº¦ï¼‰
      // ============================================================
      function createSnowParticles() {
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.snow.count * 3);
        const seeds = new Float32Array(CONFIG.snow.count);
        const intensities = new Float32Array(CONFIG.snow.count);
        const speeds = new Float32Array(CONFIG.snow.count);

        for (let i = 0; i < CONFIG.snow.count; i++) {
          const x = (Math.random() - 0.5) * CONFIG.snow.area.x;
          const y = CONFIG.snow.yBottom + Math.random() * (CONFIG.snow.yTop - CONFIG.snow.yBottom);
          const z = (Math.random() - 0.5) * CONFIG.snow.area.z;

          positions[i * 3 + 0] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;

          const depth01 = THREE.MathUtils.clamp((z + CONFIG.snow.area.z * 0.5) / CONFIG.snow.area.z, 0, 1);
          speeds[i] = THREE.MathUtils.lerp(CONFIG.snow.speedMin, CONFIG.snow.speedMax, 1 - depth01);

          // è¿œå¤„æ›´å°ã€æ›´æ·¡
          intensities[i] = THREE.MathUtils.lerp(0.25, 0.8, 1 - depth01);
          seeds[i] = Math.random() * 1000;
        }

        geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geo.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
        geo.setAttribute("aIntensity", new THREE.BufferAttribute(intensities, 1));
        geo.setAttribute("aSpeed", new THREE.BufferAttribute(speeds, 1));

        const { mat, uniforms } = makeParticleMaterial({
          pointSize: THREE.MathUtils.lerp(CONFIG.snow.sizeMin, CONFIG.snow.sizeMax, 0.55),
          breatheAmp: 0.02,
          breatheSpeed: 0.6,
          driftAmp: 0.02,
          colorCenter: CONFIG.colors.snowA,
          colorMid: CONFIG.colors.snowB,
          colorEdge: CONFIG.colors.snowA,
          blending: THREE.NormalBlending
        });
        mat.opacity = CONFIG.snow.opacity;
        mat.depthWrite = false;

        const points = new THREE.Points(geo, mat);
        points.position.y = 0;
        return { points, uniforms };
      }

      // ============================================================
      // BaseRingsï¼šåº•éƒ¨ä¸‰åœˆé‡‘è‰²ç²’å­ç¯ï¼ˆç¼“æ…¢æ—‹è½¬ï¼‰
      // ============================================================
      function createBaseRings() {
        const group = new THREE.Group();

        const { mat, uniforms } = makeParticleMaterial({
          pointSize: CONFIG.rings.pointSize,
          breatheAmp: 0.04,
          breatheSpeed: 0.9,
          driftAmp: 0.01,
          colorCenter: CONFIG.colors.gold,
          colorMid: CONFIG.colors.gold,
          colorEdge: CONFIG.colors.energyEdge,
          blending: THREE.AdditiveBlending
        });

        /** @type {THREE.Points[]} */
        const rings = [];

        for (let rIdx = 0; rIdx < CONFIG.rings.ringCount; rIdx++) {
          const radius = CONFIG.rings.radii[rIdx] ?? CONFIG.rings.radii[CONFIG.rings.radii.length - 1];
          const geo = new THREE.BufferGeometry();
          const positions = new Float32Array(CONFIG.rings.particlesPerRing * 3);
          const seeds = new Float32Array(CONFIG.rings.particlesPerRing);
          const intensities = new Float32Array(CONFIG.rings.particlesPerRing);

          for (let i = 0; i < CONFIG.rings.particlesPerRing; i++) {
            const a = (i / CONFIG.rings.particlesPerRing) * Math.PI * 2;
            const wobble = (Math.random() - 0.5) * 0.035;
            const rr = radius + wobble;
            positions[i * 3 + 0] = Math.cos(a) * rr;
            positions[i * 3 + 1] = CONFIG.rings.y + (Math.random() - 0.5) * 0.02;
            positions[i * 3 + 2] = Math.sin(a) * rr;
            seeds[i] = Math.random() * 1000;
            intensities[i] = THREE.MathUtils.clamp(0.55 + Math.random() * 0.45, 0, 1);
          }

          geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          geo.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
          geo.setAttribute("aIntensity", new THREE.BufferAttribute(intensities, 1));

          const ring = new THREE.Points(geo, mat);
          rings.push(ring);
          group.add(ring);
        }

        return { group, rings, uniforms };
      }

      // ============================================================
      // TopHeartï¼šæ ‘é¡¶å®ä½“ç«‹ä½“çˆ±å¿ƒï¼ˆæ›´äº® + æŒç»­æ—‹è½¬ï¼‰
      // ============================================================
      function createHeart() {
        const x = 0,
          y = 0;
        const heartShape = new THREE.Shape();
        heartShape.moveTo(x + 0.0, y + 0.25);
        heartShape.bezierCurveTo(x + 0.0, y + 0.25, x - 0.25, y + 0.0, x - 0.5, y + 0.0);
        heartShape.bezierCurveTo(x - 0.95, y + 0.0, x - 0.95, y + 0.6, x - 0.95, y + 0.6);
        heartShape.bezierCurveTo(x - 0.95, y + 0.95, x - 0.65, y + 1.28, x + 0.0, y + 1.55);
        heartShape.bezierCurveTo(x + 0.65, y + 1.28, x + 0.95, y + 0.95, x + 0.95, y + 0.6);
        heartShape.bezierCurveTo(x + 0.95, y + 0.6, x + 0.95, y + 0.0, x + 0.5, y + 0.0);
        heartShape.bezierCurveTo(x + 0.25, y + 0.0, x + 0.0, y + 0.25, x + 0.0, y + 0.25);

        const geo = new THREE.ExtrudeGeometry(heartShape, {
          depth: 0.22,
          bevelEnabled: true,
          bevelThickness: 0.08,
          bevelSize: 0.06,
          bevelSegments: 4,
          curveSegments: 28
        });
        geo.center();

        const mat = new THREE.MeshStandardMaterial({
          color: new THREE.Color("#ff9bd1"),
          emissive: new THREE.Color("#ff3fa5"),
          emissiveIntensity: CONFIG.heart.emissiveIntensity,
          roughness: 0.25,
          metalness: 0.15
        });

        // å¤–å‘å…‰æè¾¹ï¼šç”¨ BackSide + è½»é€æ˜ï¼Œä¿è¯â€œçˆ±å¿ƒè½®å»“â€å¯è¯»
        const rimMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color("#ffd27a"),
          transparent: true,
          opacity: 0.20,
          side: THREE.BackSide,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });

        const group = new THREE.Group();
        // ä½ç½®ï¼šæ°¸è¿œæ”¾åœ¨æ ‘é¡¶ï¼ˆç¿»è½¬åªå½±å“çˆ±å¿ƒæœ¬ä½“ï¼Œä¸å½±å“ä½ç½®ï¼‰
        group.position.set(0, CONFIG.heart.y, 0);

        const rim = new THREE.Mesh(geo, rimMat);
        rim.scale.setScalar(CONFIG.heart.scale * 1.12);
        rim.rotation.x = Math.PI * 0.12;

        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(CONFIG.heart.scale);
        mesh.rotation.x = Math.PI * 0.12;

        // å‚ç›´ç¿»è½¬ï¼šåªç¿»çˆ±å¿ƒâ€œæœ¬ä½“æ–¹å‘â€
        group.userData.baseZ = Math.PI;
        group.rotation.z = Math.PI;

        group.add(rim);
        group.add(mesh);
        return group;
      }

      // ============================================================
      // ç»„è£…â€œç»„ä»¶â€
      // ============================================================
      // åˆ†ç»„ï¼šé›ªèŠ±ä¸è·Ÿéšæ ‘ä½“æ—‹è½¬ï¼›æ ‘ä½“/ç¯/çˆ±å¿ƒ/ç…§ç‰‡åœ¨ mainGroup ä¸­
      const mainGroup = new THREE.Group();
      scene.add(mainGroup);

      const tree = createTreeParticles();
      const snow = createSnowParticles();
      const rings = createBaseRings();
      const heart = createHeart();
      const photoGroup = new THREE.Group();

      scene.add(snow.points);
      mainGroup.add(rings.group);
      mainGroup.add(tree.points);
      mainGroup.add(heart);
      mainGroup.add(photoGroup);

      // ============================================================
      // åæœŸå¤„ç†ï¼ˆBloomï¼‰
      // ============================================================
      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.post.bloomStrength, CONFIG.post.bloomRadius, CONFIG.post.bloomThreshold);
      composer.addPass(bloomPass);

      // ============================================================
      // åŠ¨ç”»å¾ªç¯ï¼ˆuseFrame çš„ç­‰ä»·å®ç°ï¼‰
      // ============================================================
      const clock = new THREE.Clock();
      /** @type {HTMLVideoElement | null} */
      let video = null;
      /** @type {HTMLCanvasElement | null} */
      let webcamCanvas = null;
      /** @type {CanvasRenderingContext2D | null} */
      let webcamCtx = null;
      /** @type {MediaStream|null} */
      let webcamStream = null;
      /** @type {'user'|'environment'} */
      let webcamFacingMode = "user";
      /** @type {HandLandmarker | undefined} */
      let handLandmarker;
      let predictRafId = null;

      /** @type {Array<THREE.Group>} */
      const photos = [];
      /** @type {Array<{group: THREE.Group, posTree: THREE.Vector3, posScatter: THREE.Vector3, baseScale: number, treeQuat: THREE.Quaternion, spin: THREE.Vector3}>} */
      const photoItems = [];

      // BGMï¼šè¯»å–assetsæ–‡ä»¶å¤¹ä¸­å¤šä¸ªmp3ï¼Œæ’åºåè¿ç»­æ’­æ”¾
      /** @type {Array<{url: string, audio: HTMLAudioElement, index: number}>} */
      const bgmList = [];
      let currentBgmIndex = 0;
      let bgmEnabled = true;

      // è‡ªåŠ¨åŠ è½½assetsæ–‡ä»¶å¤¹ä¸­çš„mp3æ–‡ä»¶ï¼ˆ1..100ï¼‰
      async function loadBgmFiles() {
        const maxAttempts = 100;
        const basePath = "assets/";
        const loaded = [];

        async function tryLoadBgm(index) {
          const url = `${basePath}${index}.mp3`;
          return new Promise((resolve) => {
            const audio = new Audio(url);
            audio.preload = "auto";
            
            const onSuccess = () => {
              audio.removeEventListener("canplaythrough", onSuccess);
              audio.removeEventListener("error", onError);
              loaded.push({ url, audio, index });
              resolve(true);
            };
            
            const onError = () => {
              audio.removeEventListener("canplaythrough", onSuccess);
              audio.removeEventListener("error", onError);
              resolve(false);
            };
            
            audio.addEventListener("canplaythrough", onSuccess, { once: true });
            audio.addEventListener("error", onError, { once: true });
            
            // å°è¯•åŠ è½½
            audio.load();
            
            // è¶…æ—¶å¤„ç†
            setTimeout(() => {
              if (!loaded.find((item) => item.index === index)) {
                onError();
              }
            }, 1500);
          });
        }

        // å¹¶å‘åŠ è½½ï¼Œä½†é™åˆ¶å¹¶å‘æ•°
        const concurrency = 8;
        for (let i = 1; i <= maxAttempts; i += concurrency) {
          const batch = [];
          for (let j = 0; j < concurrency && i + j <= maxAttempts; j++) {
            batch.push(tryLoadBgm(i + j));
          }
          await Promise.all(batch);
        }

        // æŒ‰indexæ’åº
        loaded.sort((a, b) => a.index - b.index);
        bgmList.push(...loaded);

        // è®¾ç½®æ’­æ”¾å®Œæˆäº‹ä»¶ï¼Œè‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€é¦–
        bgmList.forEach((item, idx) => {
          item.audio.addEventListener("ended", () => {
            if (!bgmEnabled) return;
            currentBgmIndex = (idx + 1) % bgmList.length;
            playCurrentBgm();
          });
        });

        // å¦‚æœæœ‰éŸ³ä¹æ–‡ä»¶ï¼Œè®¾ç½®ç¬¬ä¸€é¦–çš„éŸ³é‡
        if (bgmList.length > 0) {
          bgmList[0].audio.volume = 0.65;
        }
      }

      async function playCurrentBgm() {
        if (!bgmEnabled || bgmList.length === 0) return;
        const current = bgmList[currentBgmIndex];
        if (!current) return;
        try {
          // åœæ­¢æ‰€æœ‰å…¶ä»–éŸ³é¢‘
          bgmList.forEach((item) => {
            if (item.audio !== current.audio) {
              item.audio.pause();
              item.audio.currentTime = 0;
            }
          });
          current.audio.volume = 0.65;
          await current.audio.play();
        } catch {
          // å¿½ç•¥ï¼šéœ€è¦ç”¨æˆ·æ‰‹åŠ¿ï¼Œåç»­äº¤äº’ä¼šå†æ¬¡è§¦å‘
        }
      }

      async function tryStartBgm() {
        if (!bgmEnabled || bgmList.length === 0) return;
        await playCurrentBgm();
      }

      // åˆå§‹åŒ–åŠ è½½BGMæ–‡ä»¶
      loadBgmFiles();

      window.addEventListener("pointerdown", tryStartBgm, { once: true });
      window.addEventListener("keydown", tryStartBgm, { once: true });

      /** @param {number} dt */
      function updateSnow(dt) {
        const geo = /** @type {THREE.BufferGeometry} */ (snow.points.geometry);
        const posAttr = /** @type {THREE.BufferAttribute} */ (geo.getAttribute("position"));
        const speedAttr = /** @type {THREE.BufferAttribute} */ (geo.getAttribute("aSpeed"));
        for (let i = 0; i < CONFIG.snow.count; i++) {
          const idx = i * 3 + 1;
          posAttr.array[idx] -= speedAttr.array[i] * dt;
          if (posAttr.array[idx] < CONFIG.snow.yBottom) {
            posAttr.array[idx] = CONFIG.snow.yTop;
          }
        }
        posAttr.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const t = clock.getElapsedTime();

        if (!STATE.paused) {
          tree.uniforms.uTime.value = t;
          rings.uniforms.uTime.value = t;
          snow.uniforms.uTime.value = t;

          // é›ªèŠ±ä¸‹è½
          updateSnow(dt);

          // ç¯ç»•æ—‹è½¬
          rings.rings.forEach((r, idx) => {
            const s = CONFIG.rings.rotateSpeed[idx] ?? CONFIG.rings.rotateSpeed[0];
            r.rotation.y += s * dt;
          });

          // TREE/SCATTER/FOCUSï¼šé©±åŠ¨æ ‘ä½“ç²’å­çˆ†å¼€å¼ºåº¦
          const explodeTarget = STATE.mode === "TREE" ? 0 : 1;
          const k = 1 - Math.exp(-dt * 3.2); // å¹³æ»‘æ’å€¼
          STATE.explode += (explodeTarget - STATE.explode) * k;
          tree.uniforms.uExplode.value = STATE.explode;
          // é›ªèŠ±/ç¯ä¸çˆ†å¼€
          rings.uniforms.uExplode.value = 0;
          snow.uniforms.uExplode.value = 0;

          // é¡¶éƒ¨çˆ±å¿ƒæ—‹è½¬
          heart.rotation.y += CONFIG.heart.rotateSpeed * dt;
          // ä¿ç•™â€œå‚ç›´ç¿»è½¬â€çš„åŸºç¡€è§’åº¦ï¼ˆé¿å…è¢«åŠ¨ç”»è¦†ç›–ï¼‰
          const baseZ = /** @type {number} */ (heart.userData.baseZ ?? 0);
          heart.rotation.z = baseZ + Math.sin(t * 0.6) * 0.08;

          // è½»å¾®â€œæ”¶å›/çˆ†å¼€â€çš„æ•´ä½“å‘¼å¸ï¼ˆç…§ç‰‡ä¸ç²’å­åŠ¨æ•ˆæ›´ç»Ÿä¸€ï¼‰
          const targetScale = STATE.mode === "SCATTER" ? 1.08 : 1.0;
          mainGroup.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 2.0 * dt);

          // ç…§ç‰‡ï¼šåµŒå…¥æ ‘ä½“ / çˆ†å¼€ / ç‚¹å‡»æ”¾å¤§
          updatePhotos(dt);
        }

        controls.update();
        composer.render();
      }
      animate();

      // ============================================================
      // äº¤äº’ä¸è‡ªé€‚åº”
      // ============================================================
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") setPaused(!STATE.paused);
        if (e.key.toLowerCase() === "r") resetView();
        if (e.key.toLowerCase() === "m") toggleBgm();
        if (e.key.toLowerCase() === "h") {
          const controlsEl = document.querySelector(".upload-wrapper");
          if (controlsEl) controlsEl.classList.toggle("ui-hidden");
        }
      });

      // ============================================================
      // UI / äº¤äº’ï¼šæŒ‰é’®ã€ç…§ç‰‡ä¸Šä¼ ã€æ‘„åƒå¤´æ‰‹åŠ¿
      // ============================================================
      function setPaused(v) {
        STATE.paused = v;
        const btn = document.getElementById("btn-pause");
        if (btn) btn.textContent = `åŠ¨ç”»ï¼š${STATE.paused ? "å…³" : "å¼€"}`;
      }

      function setAutoRotate(v) {
        STATE.autoRotate = v;
        controls.autoRotate = v;
        const btn = document.getElementById("btn-autorotate");
        if (btn) btn.textContent = `è‡ªåŠ¨æ—‹è½¬ï¼š${STATE.autoRotate ? "å¼€" : "å…³"}`;
      }

      function resetView() {
        camera.position.set(CONFIG.camera.position.x, CONFIG.camera.position.y, CONFIG.camera.position.z);
        controls.target.set(CONFIG.camera.target.x, CONFIG.camera.target.y, CONFIG.camera.target.z);
        mainGroup.rotation.set(0, 0, 0);
        controls.update();
      }

      function setMode(nextMode) {
        STATE.mode = nextMode;
        if (nextMode !== "FOCUS") STATE.focusTarget = null;
      }

      document.getElementById("btn-collapse")?.addEventListener("click", () => setMode("TREE"));
      document.getElementById("btn-explode")?.addEventListener("click", () => setMode("SCATTER"));
      document.getElementById("btn-autorotate")?.addEventListener("click", () => setAutoRotate(!STATE.autoRotate));

      // æ—‹è½¬é€Ÿåº¦æ»‘åŠ¨æ¡
      document.getElementById("rotation-speed-slider")?.addEventListener("input", (e) => {
        const target = /** @type {HTMLInputElement | null} */ (e.target);
        if (!target) return;
        const value = parseFloat(target.value) / 100; // 0-1
        controls.autoRotateSpeed = value;
      });

      function toggleBgm() {
        bgmEnabled = !bgmEnabled;
        if (!bgmEnabled) {
          // æš‚åœæ‰€æœ‰éŸ³é¢‘
          bgmList.forEach((item) => {
            item.audio.pause();
          });
        } else {
          tryStartBgm();
        }
      }

      // ç…§ç‰‡ï¼šä¿æŒåŸå§‹æ¯”ä¾‹/åŸè‰²ï¼ˆä¸æ‰“å…‰ï¼‰
      function makePhotoDims(texture, maxSize) {
        const img = /** @type {any} */ (texture.image);
        const w = Math.max(1, img?.naturalWidth ?? img?.width ?? 1);
        const h = Math.max(1, img?.naturalHeight ?? img?.height ?? 1);
        const aspect = w / h;
        let pw = maxSize;
        let ph = maxSize;
        if (aspect >= 1) ph = maxSize / aspect;
        else pw = maxSize * aspect;
        return { w, h, aspect, pw, ph };
      }

      function addPhotoToScene(texture) {
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.anisotropy = 4;

        const { pw, ph } = makePhotoDims(texture, 0.28);
        
        // æ‹ç«‹å¾—é£æ ¼è¾¹æ¡†ï¼šä¸Šä¸‹å·¦å³ä¸ç­‰å®½ï¼Œåº•éƒ¨æ›´å®½
        const borderSide = 0.04;
        const borderTop = 0.04;
        const borderBottom = 0.08; // åº•éƒ¨æ›´å®½ï¼Œæ‹ç«‹å¾—é£æ ¼
        const frameW = pw + borderSide * 2;
        const frameH = ph + borderTop + borderBottom;
        const frameGeo = new THREE.PlaneGeometry(frameW, frameH);
        const photoGeo = new THREE.PlaneGeometry(pw, ph);

        // æ‹ç«‹å¾—é£æ ¼è¾¹æ¡†ï¼šç±³ç™½è‰²ç›¸çº¸è´¨æ„Ÿï¼Œä¸è§¦å‘Bloomï¼ˆäº®åº¦<0.75ï¼‰
        const frameMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(0.72, 0.71, 0.68),
          transparent: false,
          toneMapped: false,
          depthWrite: true
        });
        const photoMat = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: false,
          toneMapped: false,
          color: new THREE.Color(1, 1, 1), // ä¿æŒåŸå›¾å®Œæ•´äº®åº¦å’Œé¢œè‰²
          depthWrite: true
        });

        const frame = new THREE.Mesh(frameGeo, frameMat);
        const photo = new THREE.Mesh(photoGeo, photoMat);
        // ç…§ç‰‡å‘ä¸Šåç§»ï¼Œå› ä¸ºåº•éƒ¨è¾¹æ¡†æ›´å®½
        const offsetY = (borderBottom - borderTop) * 0.5;
        photo.position.set(0, offsetY, 0.001);

        const g = new THREE.Group();
        g.add(frame);
        g.add(photo);

        // TREE: æ›´è‡ªç„¶çš„â€œåµŒå…¥â€â€”â€”æ²¿æ ‘ä½“èºæ—‹åˆ†å¸ƒï¼Œç•¥åŸ‹å…¥ç‚¹äº‘è¡¨å±‚
        const height01 = 0.12 + Math.random() * 0.86;
        const y = height01 * CONFIG.tree.height;
        const coneR = (1 - height01) * CONFIG.tree.radius;
        const spiral = height01 * 18.0 * Math.PI; // èºæ—‹å±‚
        const a = spiral + Math.random() * Math.PI * 0.7;
        const embed = 0.10 + Math.random() * 0.18; // åŸ‹å…¥æ·±åº¦
        const rr = Math.max(0.18, coneR - embed);
        const jitter = (Math.random() - 0.5) * 0.06;
        const posTree = new THREE.Vector3(Math.cos(a) * rr + jitter, y - 0.2 + (Math.random() - 0.5) * 0.03, Math.sin(a) * rr + jitter);

        // TREE æœå¤–ï¼ˆä¸ billboard åˆ°ç›¸æœºï¼Œé¿å…â€œæ¼‚æµ®UIæ„Ÿâ€ï¼‰
        const outward = new THREE.Vector3(posTree.x, 0, posTree.z).normalize();
        const treeQuat = new THREE.Quaternion().setFromRotationMatrix(
          new THREE.Matrix4().lookAt(new THREE.Vector3(0, 0, 0), outward, new THREE.Vector3(0, 1, 0))
        );
        // plane é»˜è®¤æœ +Zï¼Œè¿™é‡Œå†è½¬ä¸€ä¸‹è®©å®ƒâ€œæ­£é¢æœå¤–â€
        treeQuat.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.PI, 0)));
        g.quaternion.copy(treeQuat);
        g.rotateX((Math.random() - 0.5) * 0.25);
        g.rotateZ((Math.random() - 0.5) * 0.35);

        // çˆ†å¼€æ€çš„æ•£å¼€ä½ç½®ï¼šçƒå£³éšæœº
        const rScatter = 4.8 + Math.random() * 3.2;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const posScatter = new THREE.Vector3(
          rScatter * Math.sin(phi) * Math.cos(theta),
          0.8 + rScatter * Math.sin(phi) * Math.sin(theta) * 0.55,
          rScatter * Math.cos(phi)
        );

        g.position.copy(STATE.mode === "TREE" ? posTree : posScatter);
        g.scale.setScalar(0.65);

        const item = {
          group: g,
          posTree,
          posScatter,
          baseScale: 0.65,
          treeQuat,
          spin: new THREE.Vector3((Math.random() - 0.5) * 0.6, (Math.random() - 0.5) * 0.6, (Math.random() - 0.5) * 0.6)
        };

        photoGroup.add(g);
        photos.push(g);
        photoItems.push(item);
      }

      function handleImageUpload(e) {
        const input = /** @type {HTMLInputElement} */ (e.target);
        const files = input.files;
        if (!files || !files.length) return;
        Array.from(files).forEach((f) => {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const url = /** @type {string} */ (ev.target?.result);
            new THREE.TextureLoader().load(url, (t) => addPhotoToScene(t));
          };
          reader.readAsDataURL(f);
        });
        input.value = "";
      }
      document.getElementById("file-input")?.addEventListener("change", handleImageUpload);

      // æ¯å¸§è®©ç…§ç‰‡æœå‘ç›¸æœºï¼ˆä¸æŠ¢æˆï¼Œè½»å¾®æ—‹è½¬ï¼‰
      function updatePhotos(dt) {
        // è®¡ç®—â€œèšç„¦â€ç›®æ ‡ç‚¹ï¼šç›¸æœºå‰æ–¹å›ºå®šè·ç¦»
        let focusLocal = null;
        if (STATE.mode === "FOCUS") {
          const dir = new THREE.Vector3().subVectors(controls.target, camera.position).normalize();
          const desiredWorld = new THREE.Vector3().copy(camera.position).addScaledVector(dir, 2.7);
          const inv = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
          focusLocal = desiredWorld.applyMatrix4(inv);
        }

        for (const item of photoItems) {
          let target = item.posTree;
          if (STATE.mode === "SCATTER") target = item.posScatter;
          else if (STATE.mode === "FOCUS") {
            if (STATE.focusTarget && item.group === STATE.focusTarget && focusLocal) target = focusLocal;
            else target = item.posScatter;
          }

          const lerpSpeed = STATE.mode === "FOCUS" && STATE.focusTarget && item.group === STATE.focusTarget ? 5.0 : 2.2;
          item.group.position.lerp(target, lerpSpeed * dt);

          // æ—‹è½¬ï¼šçˆ†å¼€æ€è‡ªç”±æ—‹è½¬ï¼›å…¶ä»–æƒ…å†µä¸‹ billboard åˆ°ç›¸æœº
          if (STATE.mode === "SCATTER") {
            item.group.rotation.x += item.spin.x * dt;
            item.group.rotation.y += item.spin.y * dt;
            item.group.rotation.z += item.spin.z * dt;
          } else if (STATE.mode === "FOCUS") {
            item.group.lookAt(camera.position);
          } else {
            // TREEï¼šä¿æŒâ€œæœå¤–åµŒå…¥â€çš„å§¿æ€
            if (item.treeQuat) item.group.quaternion.slerp(item.treeQuat, 1 - Math.exp(-dt * 6));
          }

          // ç¼©æ”¾ï¼šFOCUS æ”¾å¤§ï¼›å…¶ä»–ç»´æŒ
          let s = item.baseScale;
          if (STATE.mode === "SCATTER") s = item.baseScale * 1.15;
          if (STATE.mode === "FOCUS") {
            s = item.group === STATE.focusTarget ? item.baseScale * 3.2 : item.baseScale * 0.95;
          }
          item.group.scale.lerp(new THREE.Vector3(s, s, s), 4.0 * dt);
        }
      }

      // ï¼ˆé‡è¦ï¼‰ä¸è¦é‡å†™ composer.renderï¼šä¼šé‡å¤æ¶ˆè€— clock.getDelta()ï¼Œå¯¼è‡´åŠ¨ç”»æ—¶é—´ä¸ç¨³å®š

      // =========================
      // MediaPipeï¼šæ‰‹åŠ¿æ§åˆ¶ï¼ˆå€Ÿé‰´ åœ£è¯æ ‘.htmlï¼‰
      // =========================
      function d3(a, b) {
        const dx = a.x - b.x,
          dy = a.y - b.y,
          dz = (a.z || 0) - (b.z || 0);
        return Math.hypot(dx, dy, dz);
      }

      function fingerExtended(lm, tip, pip, mcp) {
        const m = lm[mcp],
          p = lm[pip],
          t = lm[tip];
        return d3(m, t) > d3(m, p) * 1.18;
      }

      function detectGesture(lm) {
        const thumb = fingerExtended(lm, 4, 3, 2);
        const index = fingerExtended(lm, 8, 6, 5);
        const middle = fingerExtended(lm, 12, 10, 9);
        const ringF = fingerExtended(lm, 16, 14, 13);
        const pinky = fingerExtended(lm, 20, 18, 17);
        const pinch = d3(lm[4], lm[8]) < 0.05;
        const openCount = [thumb, index, middle, ringF, pinky].filter(Boolean).length;
        if (openCount <= 1 && !pinch) return "FIST";
        if (pinch) return "PINCH";
        if (openCount >= 4) return "OPEN";
        return "NONE";
      }

      function processGestures(result) {
        if (result.landmarks && result.landmarks.length > 0) {
          STATE.hand.detected = true;
          const lm = result.landmarks[0];
          STATE.hand.x = (lm[9].x - 0.5) * 2;
          STATE.hand.y = (lm[9].y - 0.5) * 2;

          const g = detectGesture(lm);
          if (g === STATE.gesture.last) STATE.gesture.sameCount++;
          else {
            STATE.gesture.last = g;
            STATE.gesture.sameCount = 0;
          }
          if (STATE.gesture.sameCount >= 6) STATE.gesture.stable = g;

          // åŸºç¡€æ˜ å°„ï¼š
          // - FISTï¼šæš‚åœ
          // - OPENï¼šç»§ç»­
          // - PINCHï¼šåˆ‡æ¢è‡ªåŠ¨æ—‹è½¬
          // æ‰‹åŠ¿åŠ¨ä½œåšèŠ‚æµï¼Œé¿å…ç¨³å®šæ€æ¯å¸§è§¦å‘ä¸€æ¬¡
          const now = performance.now();
          const lastAt = /** @type {number} */ (STATE.gesture.lastActionAt ?? 0);
          const allow = now - lastAt > 900;

          if (STATE.gesture.stable === "FIST" && allow) {
            STATE.gesture.lastActionAt = now;
            setPaused(true);
          } else if (STATE.gesture.stable === "OPEN" && allow) {
            STATE.gesture.lastActionAt = now;
            setPaused(false);
          } else if (STATE.gesture.stable === "PINCH" && allow) {
            STATE.gesture.lastActionAt = now;
            setAutoRotate(!STATE.autoRotate);
          }

          // OPEN æ—¶ç”¨æ‰‹æŒä½ç½®åšè½»å¾®â€œæŒ‡å‘å¼â€æ—‹è½¬ï¼ˆä¸æ›¿ä»£ OrbitControlsï¼‰
          if (STATE.gesture.stable === "OPEN") {
            const targetRotY = -STATE.hand.x * Math.PI * 0.35;
            const targetRotX = STATE.hand.y * Math.PI * 0.12;
            mainGroup.rotation.y += (targetRotY - mainGroup.rotation.y) * 0.06;
            mainGroup.rotation.x += (targetRotX - mainGroup.rotation.x) * 0.06;
          }
        } else {
          STATE.hand.detected = false;
        }
      }

      async function initMediaPipe() {
        video = /** @type {HTMLVideoElement} */ (document.getElementById("webcam"));
        webcamCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("webcam-preview"));
        webcamCtx = webcamCanvas?.getContext("2d") ?? null;
        if (webcamCanvas) {
          webcamCanvas.width = 160;
          webcamCanvas.height = 120;
        }

        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        const optionsBase = {
          baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
          runningMode: "VIDEO",
          numHands: 1
        };

        try {
          handLandmarker = await HandLandmarker.createFromOptions(vision, { ...optionsBase, baseOptions: { ...optionsBase.baseOptions, delegate: "GPU" } });
        } catch {
          handLandmarker = await HandLandmarker.createFromOptions(vision, { ...optionsBase, baseOptions: { ...optionsBase.baseOptions, delegate: "CPU" } });
        }
      }

      let lastVideoTime = -1;
      function predictWebcam() {
        if (!STATE.webcamEnabled) return;
        if (!video || !handLandmarker) return;
        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;
          const result = handLandmarker.detectForVideo(video, performance.now());
          processGestures(result);
          if (webcamCtx && webcamCanvas) webcamCtx.drawImage(video, 0, 0, webcamCanvas.width, webcamCanvas.height);
        }
        predictRafId = requestAnimationFrame(predictWebcam);
      }

      async function startCamera(facingMode) {
        if (!navigator.mediaDevices?.getUserMedia) throw new Error("æµè§ˆå™¨ä¸æ”¯æŒ getUserMedia");
        if (webcamStream) webcamStream.getTracks().forEach((t) => t.stop());
        webcamStream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: { facingMode: { ideal: facingMode }, width: { ideal: 640 }, height: { ideal: 480 } }
        });
        if (!video) return;
        video.srcObject = webcamStream;
        video.muted = true;
        video.playsInline = true;
        await video.play();
      }

      function stopCamera() {
        if (predictRafId) {
          cancelAnimationFrame(predictRafId);
          predictRafId = null;
        }
        if (webcamStream) {
          webcamStream.getTracks().forEach((t) => t.stop());
          webcamStream = null;
        }
        if (video) {
          video.pause?.();
          video.srcObject = null;
        }
        STATE.hand.detected = false;
        STATE.gesture.last = "NONE";
        STATE.gesture.stable = "NONE";
        STATE.gesture.sameCount = 0;
      }

      async function setWebcamEnabled(enabled) {
        STATE.webcamEnabled = enabled;
        const toggleBtn = document.getElementById("toggle-webcam-btn");
        const switchBtn = document.getElementById("switch-camera-btn");

        if (enabled) {
          try {
            await startCamera(webcamFacingMode);
            lastVideoTime = -1;
            if (switchBtn) switchBtn.style.display = "inline-flex";
            if (toggleBtn) toggleBtn.textContent = "ğŸ¥";
            predictWebcam();
          } catch {
            STATE.webcamEnabled = false;
            if (switchBtn) switchBtn.style.display = "none";
            if (toggleBtn) toggleBtn.textContent = "ğŸš«";
            stopCamera();
          }
        } else {
          if (switchBtn) switchBtn.style.display = "none";
          if (toggleBtn) toggleBtn.textContent = "ğŸ¥";
          stopCamera();
        }
      }

      document.getElementById("toggle-webcam-btn")?.addEventListener("click", async () => {
        await setWebcamEnabled(!STATE.webcamEnabled);
      });

      document.getElementById("switch-camera-btn")?.addEventListener("click", async () => {
        webcamFacingMode = webcamFacingMode === "user" ? "environment" : "user";
        if (!STATE.webcamEnabled) return;
        await setWebcamEnabled(false);
        await setWebcamEnabled(true);
      });

      // åˆå§‹åŒ–å®Œæˆåæ·¡å‡º loaderï¼ˆå¹¶ä¸”é»˜è®¤ä¸å¯åŠ¨æ‘„åƒå¤´ï¼‰
      (async () => {
        await initMediaPipe();
        // è‡ªåŠ¨åŠ è½½ assets/ ä¸‹çš„ç…§ç‰‡ï¼ˆ1..100ï¼Œä¼˜å…ˆ jpgï¼‰
        autoLoadAssetsImages();
        const loader = document.getElementById("loader");
        if (loader) {
          loader.style.opacity = "0";
          setTimeout(() => loader.remove(), 800);
        }
      })();

      // è‡ªåŠ¨å°è¯•åŠ è½½ assets æ–‡ä»¶å¤¹ä¸­çš„ JPG/PNG å›¾ç‰‡ï¼ˆå€Ÿé‰´ åœ£è¯æ ‘.htmlï¼‰
      async function autoLoadAssetsImages() {
        const maxAttempts = 100;
        const basePath = "assets/";
        const extensions = ["jpg", "jpeg", "png"];
        async function tryLoadImage(index) {
          for (const ext of extensions) {
            const url = `${basePath}${index}.${ext}`;
            try {
              await new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(
                  url,
                  (t) => {
                    addPhotoToScene(t);
                    resolve(true);
                  },
                  undefined,
                  () => reject(false)
                );
              });
              return true;
            } catch {
              continue;
            }
          }
          return false;
        }

        const concurrency = 10;
        for (let i = 1; i <= maxAttempts; i += concurrency) {
          const batch = [];
          for (let j = 0; j < concurrency && i + j <= maxAttempts; j++) batch.push(tryLoadImage(i + j));
          await Promise.all(batch);
        }
      }

      // ç‚¹å‡»ç…§ç‰‡æ”¾å¤§/æ¢å¤ï¼ˆå€Ÿé‰´ åœ£è¯æ ‘.html çš„æ‹¾å–é€»è¾‘ï¼‰
      const raycaster = new THREE.Raycaster();
      const pointerNdc = new THREE.Vector2();
      function getPointerNdcFromEvent(ev) {
        const x = (ev.clientX / window.innerWidth) * 2 - 1;
        const y = -(ev.clientY / window.innerHeight) * 2 + 1;
        pointerNdc.set(x, y);
      }

      function findPhotoGroupFromObject(obj) {
        let cur = obj;
        while (cur && cur.parent && cur.parent !== photoGroup) cur = cur.parent;
        return cur && cur.parent === photoGroup ? cur : null;
      }

      function tryPickPhoto(ev) {
        if (STATE.mode !== "SCATTER" && STATE.mode !== "FOCUS") return;
        const panel = document.getElementById("action-panel");
        const uiLayer = document.querySelector(".ui");
        if (panel && panel.contains(ev.target)) return;
        if (uiLayer && uiLayer.contains(ev.target)) return;

        getPointerNdcFromEvent(ev);
        raycaster.setFromCamera(pointerNdc, camera);
        const hits = raycaster.intersectObjects(photoGroup.children, true);
        if (!hits.length) return;
        const picked = findPhotoGroupFromObject(hits[0].object);
        if (!picked) return;

        // è‡ªåŠ¨è§¦å‘ä¸€æ¬¡ bgm æ’­æ”¾å°è¯•ï¼ˆç”¨æˆ·æ‰‹åŠ¿ï¼‰
        tryStartBgm();

        if (STATE.mode === "SCATTER") {
          STATE.focusTarget = picked;
          setMode("FOCUS");
          return;
        }
        if (STATE.mode === "FOCUS") {
          if (STATE.focusTarget === picked) {
            STATE.focusTarget = null;
            setMode("SCATTER");
          } else {
            STATE.focusTarget = picked;
          }
        }
      }

      window.addEventListener("pointerdown", (ev) => {
        // ç‚¹å‡»èƒŒæ™¯ä¹Ÿè§¦å‘éŸ³ä¹å¯åŠ¨å°è¯•
        tryStartBgm();
        tryPickPhoto(ev);
      });
    </script>
  </body>
</html>


